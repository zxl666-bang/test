# 0. 鼠鼠我啊，要被祸害了
有1000瓶水，其中有一瓶有毒，小白鼠只要尝一点带毒的水，24小时后就会准时死亡。至少要多少只小白鼠才能在  
24小时内鉴别出哪瓶水有毒？
**思路**
先将1000转化为**二进制**（1111101000）后在每个数的位置安排一只小白鼠，根据被毒死的小白鼠来确定毒药   
的编号，即共需要1**0**只小鼠。

# 1. 先预测一下~
按照函数要求输入自己的姓名试试~


```c
  char *welcome() {
    
      // 请你返回自己的姓名
  
  }
  
  int main(void) {
    
      char *a = welcome();
      
      printf("Hi, 我相信 %s 可以面试成功!\n", a);
      
      return 0;
  
  }
  ```
**思路**
  通过设置一个**指针**用于传递字符串
**解**
  ```c
  char *ch='zhangxinlei'
  return ch;
  ```

# 2. 欢迎来到Linux兴趣小组
有趣的输出，为什么会这样子呢~

```c
  
  int main(void) {
    
      char *ptr0 = "Welcome to Xiyou Linux!";
      
      char ptr1[] = "Welcome to Xiyou Linux!";
      
      if (*ptr0 == *ptr1) {
       
        printf("%d\n", printf("Hello, Linux Group - 2%d", printf("")));
      
      }
      
      int diff = ptr0 - ptr1;
      
      printf("Pointer Difference: %d\n", diff);
  
  }
```
**思路**
- ptr0是一个**指针**，ptr1是一个**字符串组名**；
- *ptr0对指针解引用，使其**退化为字符串的第0个元素**；
- *ptr1对字符串名解引用，使其**退化为字符串第0个元素**；
- 比较二者发现相等，则第一个if内的代码可以进行；
**printf的嵌套**
  
  - 从**最内层**开始分析，从**最内层**开始输出：
  
  - 最内部的printf字符数为**0**，返回**0**，无输出；
  
  - 次外层字符数为**23**，返回**23**，输出为**Hello, Linux Group - 20**；
  
  - 最外层输出为**23**，输出为**23**；
  
  因此该printf最终输出为**Hello, Linux Group - 2023**
- 分析diff：
  -  prt0指向**字符常量**，储存在**静态区**;
  - ptr1为一个**字符数组**，存储在**栈区**;
  - 二者的内存区域**不连续**，进行的计算**无意义**，输出只是二者随机地址值之差

# 3. 一切都翻倍了吗
  
  请尝试解释一下程序的输出。
  
  请谈谈对sizeof()和strlen()的理解吧。
  
  什么是sprintf()，它的参数以及返回值又是什么呢？

  
  ```c
  int main(void) {
    
      char arr[] = {'L', 'i', 'n', 'u', 'x', '\0', '!'}, str[20];
      
      short num = 520;
      
      int num2 = 1314;
      
      printf("%zu\t%zu\t%zu\n", sizeof(*&arr), sizeof(arr + 0),
        
             sizeof(num = num2 + 4));
      
      printf("%d\n", sprintf(str, "0x%x", num) == num);
      
      printf("%zu\t%zu\n", strlen(&str[0] + 1), strlen(arr + 0));
  
  }
  ```
**思路**

- sizeof是一个**计算符**，计算的是**内存字节大小**
- %zu用于格式化输入输出函数中用于匹配**size—t**类型的格式说明符，%zu 可以确保格式化输出时与 size_t 类型**正确匹配**，避免因类型不匹配导致的输出错误
- size—t：**无符号整数类型**：
    - 内存大小（如 sizeof 运算符的返回值）
    - 数组下标、元素个数
    - 字符串长度（如 strlen 函数的返回值）
- *&arr为**arr这一整个数组**；arr+0退化为**指向a[0]的指针**；num=num+2的最终结果还是**类型为short的num**；
   - sizeof（整个数组）=**数组占内存大小**=7；
   - sizeof（指针）=8；
   - sizeof（short类型的数）=2；
- sprintf(str, "0x%x", num) ：
    - sprintf作用：
       **将输入格式化并传入目标字符串**
    - str:
    **目标字符串的地址；**
    - 0x%x:
    **格式化要求**；
    - num：
    **格式化的对象**；
    - 经过格式化num转化为十六进制转化为**205**，而0x205返回的数值为**5**，5！=520,为假，**不输出**；
    - 将**0x205**传入str中；
    - 返回值是**字符数**，（类比printf），即返回值为**5**。
- &str[0]+1指向str第1个元素即**srt[1]**，从第一个元素起开始计算str的字符串大小，为**4**；
- arr+0表示arr[0]，从第0个元素开始算，结果为**5**；
**输出**
7 8 2
  
4 5
# 4. 奇怪的输出
程序的输出结果是什么？解释一下为什么出现该结果吧~


  
 ```c
  int main(void) {
    
      char a = 64 & 127;
      
      char b = 64 ^ 127;
      
      char c = -64 >> 6;
      
      char ch = a + b - c;
      
      printf("a = %d b = %d c = %d\n", a, b, c);
      
      printf("ch = %d\n", ch);
  
  }
  ```
**思路**
  
  先将这些数全部转化为**二进制**；

  64转化为**01000000**；

  
  127转化为**01111111**；

  &：按位与，**同为1时才为1**，其余情况为0；
  
  ^:异或，**不同为1**，其余情况为0；

  >>:**右移6位**，高位补**1**；

  -64应该转化为其**补码**来处理，即为**原码反码+1**为**11000000**；
**解**
  
   a=01000000；

   b=00111111；

   c=11111111的反码即`-1`；

   ch=0111110；
# 5. 乍一看就不想看的函数
“人们常说互联网凛冬已至，要提高自己的竞争力，可我怎么卷都卷不过别人，只好用一些奇技淫巧让我的代码变得高深莫测。”

  
  这个func()函数的功能是什么？是如何实现的？

```c
int func(int a, int b) {
    if (!a) return b;
    return func((a & b) << 1, a ^ b);
}
int main(void) {
    int a = 4, b = 9, c = -7;
    printf("%d\n", func(a, func(b, c)));
}
```
**思路**
- 先将a，b，c转化成二进制数：  
  
  - a=00000100；

  - b=00001001；

  - c=11111001；
**func函数：**
  
  func(int a, int b)：输入a，b两个变量；

  if (!a) return b：如果a为**假**，返回**b**；

   return func((a & b) << 1, a ^ b)：
     
     函数的递归，再次调用函数func：
    
     (a & b)<< 1：对a，b进行按位与计算，只有当全为1时该位置上才为1。再将该数向左移，不够的位补上0；

     a ^ b：对a，b进行异或运算，不同时才为1；

     再将这两个数作为参数调用func函数，直到a为假；
  
 - 再看mian函数：
  
  先将b，c引入到func函数中，经过上述循环输出**00000010**；

  再将0001和a引入到func函数中，经过循环输出**00000110**，转化为十进制为**6**；
  # 6. 自定义过滤
  请实现filter()函数：过滤满足条件的数组元素。

  提示：使用函数指针作为函数参数并且你需要为新数组分配空间。

```c
typedef int (*Predicate)(int);
int *filter(int *array, int length, Predicate predicate,
            int *resultLength); /*补全函数*/
int isPositive(int num) { return num > 0; }
int main(void) {
    int array[] = {-3, -2, -1, 0, 1, 2, 3, 4, 5, 6};
    int length = sizeof(array) / sizeof(array[0]);
    int resultLength;
    int *filteredNumbers = filter(array, length, isPositive,
                                  &resultLength);
    for (int i = 0; i < resultLength; i++) {
      printf("%d ", filteredNumbers[i]);
    }
    printf("\n");
    free(filteredNumbers);
    return 0;
}
```
**思路**
该函数作用就是将array中的正整数输出
**解**
```c

int *filter(int *array, int length, Predicate predicate,
            int *resultLength); /*补全函数*/
int *reslutlength=0;
for(int i=0;i<length;i++)
{
if(predicate(array[i]))
{
    (*resultlength)++;//先计算出数组中正整数的个数
}
}
int*A=(int*)malloc(resultlength*sizeof(int));//设置数组，分配内存（头文件需要加上include<stdlib.h>）
if(A==NULL)
{
    *resultlength=0;
    return NULL;
} 
int n=0;
for(int i=0;i<length;i++)
{if((predicate(array[i])))
    A[n++]=array[i];
}
return A;
```
# 7. 静…态…
如何理解关键字static？  

static与变量结合后有什么作用？  

static与函数结合后有什么作用？  

static与指针结合后有什么作用？  

static如何影响内存分配？  
**解**
1. stastic核心作用是改变变量，函数的**生命周期**和**作用域**；
2. stastic与变量结合：
     - 与局部变量结合：
        - **改变生命周期**，由当前函数扩展到整个程序；
        - **不改变作用域**，仍然只在当前函数中作用；
        - 默认修饰函数的初始值为**0**；
     - 与全局变量结合：
        - **限制作用域**，从原来的整个程序限制到**当前源文件**，即无法跨文件访问，这个功能也可以实现**避免重名**，不同的文件可以设置同一个变量名；
        - **不改变生命周期**。
3. 与函数结合：
     -  **改变作用域**：
        - 从整个程序改变为**当前源文件**，不可跨文件访问。可实现**避免重名**，不同文件可以设置同一个函数名。
 4. 与指针结合：
     - 修饰指针变量本身（int stastic*A）：  
        -  与**修饰变量**一致。
     - 修饰指针指向的对象：
        - （stastic int a，int*A=&a）指针本身作用域和生命周期**不变**，只是指针指向的对象被影响，参考上文变量被stastic修饰。
5. 内存分配：
     - 内存分配分为**栈**（普通变量，函数），**堆**（手动分配），**静态分配区**。
     - 当变量或函数用stastic修饰时，就会被分配到**静态分配区**，在定义的那一刻起就开始启动直到**程序结束**才被释放，这也就解释了局部变化量生命周期延长，初始化为0且只初始化**一次**。
# 8. 救命！指针！
数组指针是什么？指针数组是什么？函数指针呢？用自己的话说出来更好哦，下面数据类型的含义都是什么呢？
```c
int (*p)[10];
const int* p[10];
int (*f1(int))(int*, int);
```
**解**
- 数组指针：表示一个**指针**，这个指针的**指向对象是一个数组**。
  
- 指针数组：表示一个**数组**，**它的元素是指针**。
   
- 函数指针：表示一个**指针**，这个指针的**指向对象是一个数组**。
- int (*p)[10]：是一个**数组指针**，表示一个**表示一个指向包含10个int类型元素数组的`指针`**。
- const int* p[10]：是一个**指针数组**，表示一个**包含10个指向对象类型为const int类型的指针的`数组`**。
- int (*f1(int))(int *, int)：  
  
  这是一个函数声明，声明函数f1返回一个**函数指针**：
   - 先看f1(int)：f1是一个**函数**，参数类型是int；
   - 再看外层(*f1(...))：f1的返回值是一个**指针**；
   - 最后看int (*)(int*, int)：这个指针是一个**函数指针**，指向的函数参数类型是`int*`和`int`，返回值类型是`int`。
**f1是一个参数类型是int，返回值是一个指向的函数参数类型为`int*`和`int`，返回值为`int`类型的`函数指针`的`函数`。**
# 9. 咋不循环了
程序直接运行，输出的内容是什么意思？

```c
int main(int argc, char* argv[]) {
    printf("[%d]\n", argc);
    while (argc) {
      ++argc;
    }
    int i = -1, j = argc, k = 1;
    i++ && j++ || k++;
    printf("i = %d, j = %d, k = %d\n", i, j, k);
    return EXIT_SUCCESS;
}
```
**思路**
  
  argc作为文件名，初始值为**1**，为非0,进入while循环之后不断自增，根据**整形溢出**，当`argc=2*pow（2,31）时argc等价于0,跳出循环；  

&&运算：  
**i！=0,为真**可进行右边运算，`argc=0为假`，因此`||`右边运算不会被**短路**；
  
**解**
i=0；j=1；k=2；
# 10. 到底是不是TWO
```c
#define CAL(a) a * a * a
#define MAGIC_CAL(a, b) CAL(a) + CAL(b)
int main(void) {
  int nums = 1;
  if(16 / CAL(2) == 2) {
    printf("I'm TWO(ﾉ>ω<)ﾉ\n");
  } else {
    int nums = MAGIC_CAL(++nums, 2);
  }
  printf("%d\n", nums);
}
```
**思路**
  
  宏定义CAL(a) a * a * a：将a用`a*a*a`替代，结合main函数得main中的cal（2）=**8**。
  
  判断if内条件：16/2*2 *2=32！=2.第一个if**不进行**；
  
  进行else：宏定义MAGIC_CAL(a, b) CAL(a) + CAL(b)中a用**num+1=2**替代，n用**2**替代，nums=2+2=4。

  但是这里计算的nums**是在else内定义的**，**作用域是在else中**，因此else之外输出的nums仍为**1**。
# 11. 克隆困境
试着运行一下程序，为什么会出现这样的结果？

直接将s2赋值给s1会出现哪些问题，应该如何解决？请写出相应代码。

```c
struct Student {
    char *name;
    int age;
};

void initializeStudent(struct Student *student, const char *name,int age) {
    student->name = (char *)malloc(strlen(name) + 1);
    strcpy(student->name, name);
    student->age = age;
}
int main(void) {
    struct Student s1, s2;
    initializeStudent(&s1, "Tom", 18);
    initializeStudent(&s2, "Jerry", 28);
    s1 = s2；
    printf("s1的姓名: %s 年龄: %d\n", s1.name, s1.age);
    printf("s2的姓名: %s 年龄: %d\n", s2.name, s2.age);
    free(s1.name);
    free(s2.name);
    return 0;
} 
```
**思路**
   
   s1，s2是两个**结构体**， s1 = s2是**结构体赋值**，**s1的内容全部对应粘贴s2的内容**导致输出的s1,s2全部都是**s2的对应内容**。
   
   但是name是一个**指针**，这样直接赋值会使s1和s2中的name**指向同一个地址**，而后续会对该地址进行**两次**内存释放，而原来s1中name对应的地址没有实现内存释放，可能造成**内存泄漏**。

   修改方法
   ```c
   void huan(struct Student*A,const Student*B int age)
   {
    free(A->name);
    A->name = (char *)malloc(strlen(B->name) + 1);
    strcpy(A->name, B->name);
   A->age = B->age;
   }
   int main(void) {
    struct Student s1, s2;
    initializeStudent(&s1, "Tom", 18);
    initializeStudent(&s2, "Jerry", 28);
    s1 = s2；换成：huan（&s1,&s2）
    printf("s1的姓名: %s 年龄: %d\n", s1.name, s1.age);
    printf("s2的姓名: %s 年龄: %d\n", s2.name, s2.age);
    free(s2.name);
    return 0;
} 
```
# 12. 你好，我是内存
作为一名合格的C-Coder，一定对内存很敏感吧~来尝试理解这个程序吧！

```c
struct structure {
    int foo;
    union {
      int integer;
      char string[11];
      void *pointer;
    } node;
    short bar;
    long long baz;
    int array[7];
};
int main(void) {
    int arr[] = {0x590ff23c, 0x2fbc5a4d, 0x636c6557, 0x20656d6f,
                 0x58206f74, 0x20545055, 0x6577202c, 0x6d6f636c,
                 0x6f742065, 0x79695820, 0x4c20756f, 0x78756e69,
                 0x6f724720, 0x5b207075, 0x33323032, 0x7825005d,
                 0x636c6557, 0x64fd6d1d};
    printf("%s\n", ((struct structure *)arr)->node.string);
}
```
**思路**
- union是一个**联合体**，其中元素共占一块内存空间，取最大成员的内存空间即可，int类型的integer占**4**字节，char类型的string占**11**字节，**pointer**是**指针**，占**8**字节，所以union占**11**字节,但是union的最大成员数是**8**，所以union内存需要扩大到8的整数倍所以应该为**16**；
- - int foo：**0-3**
  - node：**8-23**
  - bar：**24-25**
  - baz：**32-39**
  - array：**40-67**
  - 最大成员数为**8**，则内存对齐最终结果为**72**
- 程序将 arr 强制转换为` struct structure *` 类型，
数组 arr 的内存等同于 struct structure 结构体的内存。
arr 中的整数会被视作**结构体成员在内存中的二进制数据**。
- node.string从它的起始位置**8** ，共 **64** 字节到数组 arr 中，就是从 arr[2] 开始的部分（因为arr为**int**类型占4字节），再将十六进制转而来的数字根据**ASCII码**对应的**字母**。
- node.string 对应的内存字节  
  
    
    - arr[2] = 0x636c6557  拆为**0x57, 0x65, 0x6c, 0x63**
    - arr[3] = 0x20656d6f  拆为**0x6f, 0x6d, 0x65, 0x20**
    - arr[4] = 0x58206f74  拆为**0x74, 0x6f, 0x20, 0x58**
    - arr[5] = 0x20545055  拆为**0x55, 0x50, 0x54, 0x20**
    - 以此类推直到arr[15]中出现**0x00**,它对应的字符为`\0`，终止编译。
  - 将这些字节转换为 ASCII 字符：
  
    - 字符串以 \0 结尾，实际有效字符是从第一个可打印序列开始的 **"Welcome to XUPT, welcome to Xiyou Linux Group [2023]"**


# 注：嘿！你或许对 Linux 命令不是很熟悉，甚至你没听说过 Linux。但别担心，这是选做题，了解 Linux 是加分项，但不了解也不扣分哦！

## 你知道 cd 命令的用法与 / ~ - 这些符号的含义吗？
  
  cd用于切换到**当前目录**，cd/切换到**根目录** ～切换到**主目录**，cd-切换到**上一个目录**
## Linux 系统如何创建和删除一个目录吗？
  
  **mkdir**创建，
  
  **rmdir**删除空目录，
  
  **rm-rf-需要删的非空目录**





  