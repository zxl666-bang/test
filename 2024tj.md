# 0. 聪明的吗喽
一个小猴子边上有 100 根香蕉，它要走过 50 米才能到家，每次它最多搬 50 根香蕉，（多了就拿不动了），它每走 1 米就要吃掉一根，请问它最多能把多少根香蕉搬到家里。

（提示：他可以把香蕉放下往返走，但是必须保证它每走一米都能有香蕉吃。也可以走到 n 米时，放下一些香蕉，拿着 n 根香蕉走回去重新搬 50 根。）

**思路**
假设先抱着50根香蕉走了n米，之后再返回原点取剩余的50根香蕉，则此时在n米处有**100-3n**根香蕉，这时我希望能够将这些香蕉一次性抱走这样就可以免去往返消耗的香蕉，因此**100-3n<=50**，即**n<17**,则n=16,最后还剩`100-3n-（50-n）`根香蕉，计算得可以把**16**根香蕉带回去。
# 1. 西邮Linux欢迎你啊
请解释以下代码的运行结果。

```c
int main() {
    unsigned int a = 2024;
    for (; a >= 0; a--)
        printf("%d\n", printf("Hi guys! Join Linux - 2%d", printf("")));
    return 0;
}
```
**思路**
- unsigned int a = 2024：a是一个**无符号数**，不小于**0**且不大于**pow（2,32）-1**
- for (; a >= 0; a--)：从a=2024开始循环，每循环一次a-1直到a<0。但是结合a的范围得a永远大于0,即这个循环会**一直进行下去**
- printf的嵌套：从**最里面**的printf开始输出并**返回字符数**。
**输出**
循环输出**Hi guys! Join Linux - 2024**。
# 2. 眼见不一定为实
输出为什么和想象中不太一样？

  
  你了解 sizeof() 和 strlen() 吗？他们的区别是什么？
```c
int main() {
    char p0[] = "I love Linux";
    const char *p1 = "I love Linux\0Group";
    char p2[] = "I love Linux\0";
    printf("%d\n%d\n", strcmp(p0, p1), strcmp(p0, p2));
    printf("%d\n%d\n", sizeof(p0) == sizeof(p1), strlen(p0) == strlen(p1));
    return 0;
}
```
**思路**
- strcmp函数：逐个比较字符串内字符在**字符典**中位置，且遇到`\0`会结束读取，字符越**靠后**代表其越**大**。  
   - 若前大于后：输出一个大于**0**的数；
   - 若前等于后：输出**0**；
   - 若前小于后：输出一个小于**0**的数。
- sizeof计算**内存字节大小**，需要记上`\0`，且遇到`\0`不会结束计算;
- strlen计算**字符串长度**，读取到`\0`结束读取。
**解**
- strcmp(p0, p1)=strcmp(p0, p2)=**0**
- sizeof(p0) == sizeof(p1)为**假**，输出**0**
- strlen(p0) == strlen(p1)为**真**，输出**1**
# 3. 1.1 - 1.0 != 0.1
为什么会这样，除了下面给出的一种方法，还有什么方法可以避免这个问题？

```c
int main() {
    float a = 1.0, b = 1.1, ex = 0.1;
    printf("b - a == ex is %s\n", (b - a == ex) ? "true" : "false");
    int A = a * 10, B = b * 10, EX = ex * 10;
    printf("B - A == EX is %s\n", (B - A == EX) ? "true" : "false");
}
```
**思路**
- 浮点数的**精度损失**：
  十进制转化为二进制的存储格式为**符号位+指数+尾数**，其中**尾数**位数受到精度位数限制（float可保留23位，double可以保留52位），当十进制转为的二进制为**无限小数**时就会造成由于尾数存储不全导致的**精度损失**
**解**
- 输出：
  - b - a == ex is false
  - B - A == EX is true
- 解决方法：
  1. 将原来的浮点数转化为`整数*10的n次幂`形式（即题示）；
  2. **定义一个极小的数**，当二者误差小于该数时认为相等
 ```c
 int panduan(float x,float y,float z)
 {
    double q=1e-10;
    if(x-y-z<q)
    {
        return 1;
    }
   return 0;
 }
 int main()
 {
    float a=1.0;
    float b=1.1;
    float ex=0.1;
     printf("b - a == ex is %s\n", (panduan(a,b,ex)) ? "true" : "false");
     return 0;
 }
```
# 4. 听说爱用位运算的人技术都不太差
解释函数的原理，并分析使用位运算求平均值的优缺点。

```c
int average(int nums[], int start, int end) {
    if (start == end)
        return nums[start];
    int mid = (start + end) / 2;
    int leftAvg = average(nums, start, mid);
    int rightAvg = average(nums, mid + 1, end);
    return (leftAvg & rightAvg) + ((leftAvg ^ rightAvg) >> 1);
}
```
**思路**
- leftAvg=nums数组前半部分的平均数；
- rightAvg=nums数组后半部分的平均数；
- &：**按位与**运算，当对应的位上**都为1**时才为**1**，否则为0；
- ^：**按位异或**，当对应位上**不相同**时为**1**，否则为0；
- `>>`1:**右移1位**，若位数不够往前补**1**；
- 
```c  
if (start == end)
        return nums[start]
```
若首末相等则该数组平均值就等于**首项或末项**。
```c
 (leftAvg & rightAvg) + ((leftAvg ^ rightAvg) >> 1)
```
`设两个数分别为a，b`
- **&**将都是**1**的位次提取出来，设结果为**c**，如果c的某位为**1**，则说明a
  ,b在该位都为1,而a+b会导致这个**1**往前移1位，那么如果我把**c扩大一倍**，就可以得出**相同位次都为1时的加法结果**；
- **^**可以看作一个**不进位的加法**，设该结果为**d**，也就是实现了**相同位次不同为1时的加法**；
- a+b=c*2+d：
  - （a+b）/2=（c*2+d）/2=**c+d>>1**
- 优点：
      1. 直接在二进制的基础上操作，可以**更高效**完成计算 ；
      2. 按位与和按位异或操作都是直接在原二进制位次上操作，**不用担心由于a，b相加和过大造成的整数溢出**；
      3. &，^，>>，<<都是**位运算符**，这是**硬件直接支持的基础运算**，无需额外的除法器模块，**底层适配型强**。
- 缺点：
     与自然语言相比**更难懂**。
# 5. 全局还是局部!!!
先思考输出是什么，再动动小手运行下代码，看跟自己想得结果一样不一样 >-<

```c
int i = 1;
static int j = 15;
int func() {
    int i = 10;
    if (i > 5) i++;
    printf("i = %d, j = %d\n", i, j);
    return i % j;
}
int main() {
    int a = func();
    printf("a = %d\n", a);
    printf("i = %d, j = %d\n", i, j);
    return 0;
}
```
**思路**
- 一开始定义**全局变量i=1**，**静态全局变量j=15**
- func函数中定义**局部变量i=10**,它的**生命周期和作用域都在func函数中**，**局部变量的优先级高于全局变量**，即取i=**10**，满足if内的条件，i自增为**11**，j=15，返回**11**；
- main函数中a=func的返回值，即**11**；
- main中的i**取全局变量**i=10；
**输出**
  i = 11, j = 15
  
  a = 11
  
  i = 1, j = 15
# 6. 指针的修罗场：改还是不改，这是个问题
指出以下代码中存在的问题，并帮粗心的学长改正问题。

```c
int main(int argc, char **argv) {
    int a = 1, b = 2;
    const int *p = &a;
    int * const q = &b;
    *p = 3, q = &a;
    const int * const r = &a;
    *r = 4, r = &b;
    return 0;
}
```
**错误**
1. `*p = 3`:
   - const int *p 定义了1个**指向对象为常量**的指针，即p的**指向对象内容不能变**，所以`*p=a=1`。
2. `q = &a`:
   - int * const q = &b 定义了1个**常量指针**q，即q的**指向对象不能变**，所以`q只能=&b`。
3. ` *r = 4, r = &b`:
   -  const int * const r 定义了1个**指向对象为常量**的**常量指针**，即r的**指向对象和指向对象的内容都不变**，所以`r=&a` `*r=a=1`
# 7. 物极必反？
你了解 argc 和 argv 吗，这个程序里的 argc 和 argv 是什么？

  
  程序输出是什么？解释一下为什么。

```c
int main(int argc, char *argv[]) {
    while (argc++ > 0);
    int a = 1, b = argc, c = 0;
    if (--a || b++ && c--)
        for (int i = 0; argv[i] != NULL; i++)
            printf("argv[%d] = %s\n", i, argv[i]);
    printf("a = %d, b = %d, c = %d\n", a, b, c);
    return 0;
}
```
**思路**
- argc：**参数记数**，表示**命令行参数的总个数**，因为包含**程序本身**，所以至少为**1**，若没有特别说明默认为**1**，范围为`{-pow(2,31),pow(2,32)-1}`；
- argv：**参数向量**，是一个**指向字符串数组的指针的数组**，每个元素argv[i]是1个**指针**：
    -  argv[0]:表示**程序名**；
    -  argv[1]-argv[argv-1]:表示输入的命令；
    -  argv[argc]=NULL;
- while循环内argc由1开始不断自增直到**整形溢出**，此时`argc=-pow(2,31)`，跳出循环；
- --a=0为**假**，则会进行||右侧的运算，b++=-pow(2,31)+1小于0为**假**，则不可以进行&&右侧的运算，c=0.最终结果为**假**，则if内代码不运行；
**输出**
`0` `-pow（2,31）+1` `0`
# 8. 指针？数组？数组指针？指针数组？
在主函数中定义如下变量：

```c
int main() {
    int a[2] = {4, 8};
    int(*b)[2] = &a;
    int *c[2] = {a, a + 1};
    return 0;
}
说说这些输出分别是什么？


 a, a + 1, &a, &a + 1, *(a + 1), sizeof(a), sizeof(&a)
 *b, *b + 1, b, b + 1, *(*b + 1), sizeof(*b), sizeof(b)
 c, c + 1, &c, &c + 1, **(c + 1), sizeof(c), sizeof(&c)
```
**思路**
- a：**数组名**；
- b：**数组指针**，包含2个**int**类型的数组，指向**数组a**；
- c：**指针数组**，包含2个指向对象类型为**int**的指针，一个指向**a[0]地址**，一个指向**a[1]地**；
- &a与a：
   - &a：**数组指针**，类型为int（*）[2],指向a这个数组；
   - a退化为指向a[0]的指针时类型为`int*`；
   - 二者数值上都等于**a[0]的地址**；
**解**
- a：a会退化为**指向a首元素的指针**，输出**a[0]地址**；
- a+1：**由a[0]往后移一个单位**，输出**a[1]地址**；
- &a：取**整个数组a的地址**，由前得输出**a[0]地址**；
- &a+1：数组a向后偏移**一个数组字节大小**，未定义区域，输出**a[1]之后的一块地址**；
- *（a+1）：对&a[1]解引用，即输出**a[1]的值**，**8**；
- sizeof（a）：a数组（类型为int）的内存字节大小=**2*4=8**；
- sizeof（&a）：**sizeof（地址）=8**；
- *b：对数组指针解引用，得到**数组a本身**，输出a时退化为指向首元素的指针，即输出**a[0]的地址**；
- *b+1：输出a[0]往后移一个int单位后元素的地址,即**a[1]地址**；
- b：b指向数组a，等同于输出`&a`，输出**a[0]的地址**；
- b+1：**偏移1个数组大小**,在未定义区域，输出**a数组之后的一块地址**；
- *（*b+1）：
     - *b+1：指向a[0]的指针向后偏移一个int单位，即指向**a[1]的指针** ；
     - *（*b+1）：解引用指向a[1]的指针，输出a[1]的值**8**；
- sizeof(*b)：输出数组a的内存字节大小，a为int类型数组输出**2*4=8**；
- sizeof（b）：指针内存字节大小为**8**，输出**8**；
- c：数组退化为**指向首元素的指针**，输出**c[0]的地址**；
- c+1：数组计算，c[0]向后移一个int单位，为c[1]，输出**c[1]的地址**；
- &c：取c首元素地址，根据c的输出类比得出，输出**c[0]的地址**；
- &c+1：&c指向c这一整个数组，+1表示跳过一个数组长度，是一块未定义区域，输出**c数组之后的一块地址**；
- **（c+1）
     - *（c+1）：对c+1解引用，得**c[1]的值即为指向a[1]的指针**；
     - **（c+1）：对指向a[1]指针解引用，输出a[1]的值，即输出`8`；
- sizeof(c):c数组的内存字节大小，`指针数组大小=元素个数*指针大小`输出**2*8=16**；
- sizeof（&c）：地址内存大小，输出**8**。
# 9. 嘻嘻哈哈，好玩好玩
在宏的魔法下，数字与文字交织，猜猜结果是什么？

```c
#define SQUARE(x) x *x//宏定义用x*x代替x
#define MAX(a, b) (a > b) ? a : b;//宏定义，若括号内为真，输出冒号前内容，反之输出冒号后
#define PRINT(x) printf("嘻嘻，结果你猜对了吗，包%d滴\n", x);//输出一串字符
#define CONCAT(a, b) a##b//CONCAT是一个拼接函数，将a，b无分隔符地拼接到一起。
//  ##是宏专用运算符，作用是将b拼接到a之后形成新的变量名

int main() {
    int CONCAT(x, 1) = 5;//int x1=5
    int CONCAT(y, 2) = 3;//int y2=3
    int max = MAX(SQUARE(x1 + 1), SQUARE(y2))//Max（11,3）；
    PRINT(max)
    return 0;
}
```
**思路**
- CONCAT与##
    - CONCAT作用对象是**运行数据**，得出来的结果是**一串字符串**，本质是**数据拼接**；
    - ##作用对象是**编译时的代码令牌**，得出来的结果是**一个新的代码标识符**，本质是**代码拼接**；
    - 如 int a=1；int b=0
       1. CONCAT(a,b)结果是**ab**；
       2. a##b结果是**10**。
- 将x1+1看作x计算`不带括号`：x1+1*x1+1=11
**解**
`嘻嘻，结果你猜对了吗，包11滴`
# 10. 我写的排序最快
写一个 your_sort 函数，要求不能改动 main 函数里的代码，对 arr1 和 arr2 两个数组进行升序排序并剔除相同元素，最后将排序结果放入 result 结构体中。

```c
int main() {
    int arr1[] = {2, 3, 1, 3, 2, 4, 6, 7, 9, 2, 10};
    int arr2[] = {2, 1, 4, 3, 9, 6, 8};
    int len1 = sizeof(arr1) / sizeof(arr1[0]);
    int len2 = sizeof(arr2) / sizeof(arr2[0]);

    result result;
    your_sort(arr1, len1, arr2, len2, &result);
    for (int i = 0; i < result.len; i++) {
        printf("%d ", result.arr[i]);
    }
    free(result.arr);
    return 0;
}
```
**解**
```c
#include<stdio.h>
#include<stdlib.h>
typedef struct
{
int len;
int*arr;
}result;
void your_sort(int arr1[],int len1,int arr2[],int len2,result*result)
{
    result->len=len1+len2;
    result->arr=(int*)malloc(result->len*sizeof(int));
    if(result->arr==NULL)
    {
        result->len=0;
        return;
    }
    for(int i=0;i<len1;i++)
    {
        result->arr[i]=arr1[i];
    }
    for(int i=len1;i<result->len;i++)
    {
        result->arr[i]=arr2[i-len1];
    }
    for(int i=0;i<result->len-1;i++)
    {
      for(int j=0;j<result->len-i-1;j++)
      {
         int temp=result->arr[j];
         if(result->arr[j]>result->arr[j+1])
         {
            result->arr[j]=result->arr[j+1];
            result->arr[j+1]=temp;
         }
      }
    }
    int count=1;
    for(int i=0;i<result->len-1;i++)
    {
       if(result->arr[i]!=result->arr[i+1])
       {
        count++;
       }
    }
    int*arr=(int*)malloc(count*sizeof(int));
    if(arr==NULL)
    {
        free(result->arr);
        result->arr=NULL;
        count=0;
        return;
    }
    int n=0;
    arr[n++]=result->arr[0];
    for(int i=0;i<result->len-1;i++)
    {
        if(result->arr[i]!=result->arr[i+1])
        {
            arr[n++]=result->arr[i+1];
        }
    }
    free(result->arr);
    result->arr=arr;
    result->len=count;
}
int main() {
    int arr1[] = {2, 3, 1, 3, 2, 4, 6, 7, 9, 2, 10};
    int arr2[] = {2, 1, 4, 3, 9, 6, 8};
    int len1 = sizeof(arr1) / sizeof(arr1[0]);
    int len2 = sizeof(arr2) / sizeof(arr2[0]);

    result result;
    your_sort(arr1, len1, arr2, len2, &result);
    for (int i = 0; i < result.len; i++) {
        printf("%d ", result.arr[i]);
    }
    free(result.arr);
    return 0;
}
```
# 11. 猜猜我是谁
在指针的迷宫中，五个数字化身为神秘的符号，等待被逐一揭示。

```c
int main() {
    void *a[] = {(void *)1, (void *)2, (void *)3, (void *)4, (void *)5};
    printf("%d\n", *((char *)a + 1));
    printf("%d\n", *(int *)(char *)a + 1);
    printf("%d\n", *((int *)a + 2));
    printf("%lld\n", *((long long *)a + 3));
    printf("%d\n", *((short *)a + 4));
    return 0;
}
```
**思路**
- a是一个**指针数组**，每个元素是一个指针，字节大小为**8**；
- 假设a[0]地址为A
```c
      -  元素     内存地址     存储内容
      -  a[0]    A          0x0000000000000001
      -  a[1]    A+8        0x0000000000000002
      -  a[2]    A+16       0x0000000000000003
      -  a[3]    A+24       0x0000000000000004
      -  a[4]    A+32       0x0000000000000005
```
- *((char *)a + 1)：将a转换成char类型，则每次偏移**1**字节，a+1指向a[0]地址的第2个字节，即**0x00**，对该地址解引用输出**0**；
- *(int *)(char *)a + 1：将a转成char类型后再转成int类型，则每次偏移**4**个字节，此时指向a[0]的前**4**个字节，对该地址解引用得到**0x00000001**，结果+1,输出**2**；
- *((int *)a + 2)：将a转化为int类型，每次偏移**4**字节，a+2指向a[1]的首地址，即**0x00000002**，对该地址解引用，输出**2**；
- *((long long *)a + 3)：将a转化成long long类型，则每次偏移**8**字节，a+3偏移**24**字节，指向a[3]首地址，解引用后得**4**；
- *((short *)a + 4)：将a转化为short类型，每次偏移**2**个字节，a+4偏移**8**个字节，即指向a[1]首地址，解引用后输出**2**；
# 12. 结构体变小写奇遇记
计算出 Node 结构体的大小，并解释以下代码的运行结果。

```c
union data {
    int a;
    double b;
    short c;//union是联合体，元素共占一块内存，其中占内存最大为8且最大成员字节数也是8,所以union占8字节
};
typedef struct node {
    long long a;//8字节，占0-7；
    union data b;//8字节，占8-15；
    void (*change)( struct node *n);//change是一个函数指针，占8字节，占16-13；
    char string[0];//柔性数组，内存还未定义，占0字节
} Node;//内存大小为24
void func(Node *node) {
    for (size_t i = 0; node->string[i] != '\0'; i++)//读取string字符串
        node->string[i] = tolower(node->string[i]);//tolower将字符串中大写字母变小写
}

int main() {
    const char *s = "WELCOME TO XIYOULINUX_GROUP!";
    Node *P = (Node *)malloc(sizeof(Node) + (strlen(s) + 1) * sizeof(char));//分配内存，(strlen(s) + 1) * sizeof(char)给柔性数组分配内存
    strcpy(P->string, s);//用s代替string内的字符
    P->change = func;//chang指针绑定func函数，即调用change指针相当于调用func函数
    P->change(P);//调用func函数处理P
    printf("%s\n", P->string);
    return 0;
}
```
# 13. GNU/Linux (选做)
注：嘿！你或许对Linux命令不是很熟悉，甚至没听说过Linux。
- 但别担心，这是选做题，了解Linux是加分项，不了解也不扣分哦！

**你知道 cd 命令的用法与 / ~ - 这些符号的含义吗?**
  
  cd用于切换到**当前目录**，cd/切换到**根目录** ～切换到**主目录**，cd-切换到**上一个目录**
**Linux 系统如何创建和删除一个目录吗？**
  
 -  **mkdir**创建，
  
 -  **rmdir**删除空目录，
  
 -  **rm-rf-需要删的非空目录**


